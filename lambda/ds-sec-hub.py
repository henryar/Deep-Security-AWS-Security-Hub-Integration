import datetime
import json
import os

import boto3
from botocore.exceptions import ClientError

AWS_REGION = os.environ['AWS_REGION']

FIREWALL_REPEAT_THRESHOLD = int(os.getenv('FIREWALL_REPEAT_THRESHOLD', 5))
IPS_SEVERITY_THRESHOLD = int(os.getenv('IPS_SEVERITY_THRESHOLD', 3))
WEB_REPUTATION_THRESHOLD = int(os.getenv('WEB_REPUTATION_THRESHOLD', 3))
INTEGRITY_MONITORING_THRESHOLD = int(os.getenv('INTEGRITY_MONITORING_THRESHOLD', 3))
LOG_INSPECTION_THRESHOLD = int(os.getenv('LOG_INSPECTION_THRESHOLD', 8))

AFF_REQUIRED_PROPERTIES = [
    'HostOwnerID',
    'HostInstanceID',
    'TenantID',
    'EventID',
    'EventType',
]

AFF_EVENT_TYPES = {
    'SystemEvent': 'system',
    'PacketLog': 'firewall',
    'PayloadLog': 'ips',
    'AntiMalwareEvent': 'antimalware',
    'WebReputationEvent': 'webreputation',
    'IntegrityEvent': 'integrity',
    'LogInspectionEvent': 'log',
    'AppControlEvent': 'applicationcontrol',
}

DS_PRODUCT_ARNS = {
    'us-east-2': 'arn:aws:securityhub:us-east-2:679593333241:product/trend-micro/deep-security',
    'us-east-1': 'arn:aws:securityhub:us-east-1:679593333241:product/trend-micro/deep-security',
    'us-west-1': 'arn:aws:securityhub:us-west-1:679593333241:product/trend-micro/deep-security',
    'us-west-2': 'arn:aws:securityhub:us-west-2:679593333241:product/trend-micro/deep-security',
    'ap-south-1': 'arn:aws:securityhub:ap-south-1:679593333241:product/trend-micro/deep-security',
    'ap-northeast-2': 'arn:aws:securityhub:ap-northeast-2:679593333241:product/trend-micro/deep-security',
    'ap-southeast-1': 'arn:aws:securityhub:ap-southeast-1:679593333241:product/trend-micro/deep-security',
    'ap-southeast-2': 'arn:aws:securityhub:ap-southeast-2:679593333241:product/trend-micro/deep-security',
    'ap-northeast-1': 'arn:aws:securityhub:ap-northeast-1:679593333241:product/trend-micro/deep-security',
    'ca-central-1': 'arn:aws:securityhub:ca-central-1:679593333241:product/trend-micro/deep-security',
    'eu-central-1': 'arn:aws:securityhub:eu-central-1:679593333241:product/trend-micro/deep-security',
    'eu-west-1': 'arn:aws:securityhub:eu-west-1:679593333241:product/trend-micro/deep-security',
    'eu-west-2': 'arn:aws:securityhub:eu-west-2:679593333241:product/trend-micro/deep-security',
    'eu-west-3': 'arn:aws:securityhub:eu-west-3:679593333241:product/trend-micro/deep-security',
    'sa-east-1': 'arn:aws:securityhub:sa-east-1:679593333241:product/trend-micro/deep-security',
}


class DeepSec:
    def __init__(self, ds_event):
        self.ds_event = ds_event
        self.event_type = ds_event['EventType']
        self.host_instance_id = self.ds_event['HostInstanceID']

        self.event_processor = {
            'SystemEvent': self._process_system_event,
            'PacketLog': self._process_packet_log,
            'PayloadLog': self._process_payload_log,
            'AntiMalwareEvent': self._process_anti_malware,
            'WebReputationEvent': self._process_web_reputation,
            'IntegrityEvent': self._process_integrity_event,
            'LogInspectionEvent': self._process_log_inspection,
            'AppControlEvent': self._process_app_control_event,
        }

        self.aff_payload = self._generate_aff_payload()

    @staticmethod
    def _process_system_event():
        # Ignore, generated by Deep Security as a platform. Includes events like
        # agent updates, communication issues, etc.
        print('Ignoring System Event from Deep Security')

        return False

    def _process_packet_log(self):
        # Firewall events
        get_repeat_count = self.ds_event.get('RepeatCount')
        repeat_count = int(get_repeat_count) if get_repeat_count else None

        if not repeat_count or repeat_count < FIREWALL_REPEAT_THRESHOLD:
            self._print_threshold_message('Firewall', FIREWALL_REPEAT_THRESHOLD, above_threshold=False)

            return False

        self._print_threshold_message('Firewall', FIREWALL_REPEAT_THRESHOLD, above_threshold=True)

        self.aff_payload['Severity']['Product'] = 0
        self.aff_payload['Severity']['Normalized'] = 20  # An 'could result in future compromises'
        self.aff_payload['Types'].append('Unusual Behaviors/Network Flow')
        self.aff_payload['Title'] = generate_title(f'Repeated attempted network connection on '
                                                   f'instance {self.host_instance_id}')

        return True

    def _process_payload_log(self):
        # Intrusion prevention events
        get_severity = self.ds_event.get('Severity')
        severity = int(get_severity) if get_severity else None

        if not severity or severity < IPS_SEVERITY_THRESHOLD:
            self._print_threshold_message('IPS', IPS_SEVERITY_THRESHOLD, above_threshold=False)

            return False

        self._print_threshold_message('IPS', IPS_SEVERITY_THRESHOLD, above_threshold=True)

        self.aff_payload['Severity']['Product'] = severity
        # to match the 31-70 range in the AFF format
        self.aff_payload['Severity']['Normalized'] = int(severity * 17.5)

        # Add the finding type
        trigger_reason = self.ds_event['Reason']

        self.aff_payload['Types'].append('Software and Configuration Checks Vulnerabilities/Vulnerabilities/CVE')
        self.aff_payload['Title'] = generate_title(f'Rule triggered: {trigger_reason}')

        return True

    def _process_anti_malware(self):
        infected_path = self.ds_event['InfectedFilePath']
        malware_name = self.ds_event['MalwareName']

        print(f'Malware event ({malware_name}) detected on {self.host_instance_id } - Infected path: {infected_path}')

        self.aff_payload['Malware'] = [
            {
                'Name': malware_name,
                'Path': infected_path,
            }
        ]

        self.aff_payload['Types'].append('TPPs/Execution')
        self.aff_payload['Title'] = generate_title(f'Malware detected: {malware_name}')

        return True

    def _process_web_reputation(self):
        get_risk = self.ds_event.get('Risk')
        risk = int(get_risk) if get_risk else None

        if not risk or risk < WEB_REPUTATION_THRESHOLD:
            self._print_threshold_message('IPS', WEB_REPUTATION_THRESHOLD, above_threshold=False)

            return False

        self.aff_payload['Severity']['Product'] = risk
        # to match the 31-70 range in the AFF format
        self.aff_payload['Severity']['Normalized'] = int(risk * 17.5)
        self.aff_payload['Types'].append('TPPs/Execution')

        target_ip = self.ds_event['TargetIP']
        title = f'High risk web request to IP: {target_ip}'
        self.aff_payload['Title'] = generate_title(title)

        self._print_threshold_message('IPS', WEB_REPUTATION_THRESHOLD, above_threshold=True, additional_info=title)

        return True

    def _process_integrity_event(self):
        get_severity = self.ds_event.get('Severity')
        severity = int(get_severity) if get_severity else None

        if not severity or severity < INTEGRITY_MONITORING_THRESHOLD:
            self._print_threshold_message('Integrity Monitoring', INTEGRITY_MONITORING_THRESHOLD, above_threshold=False)

            return False

        self._print_threshold_message('Integrity Monitoring', INTEGRITY_MONITORING_THRESHOLD, above_threshold=True)

        self.aff_payload['Severity']['Product'] = severity

        # to match the 31-70 range in the AFF format
        self.aff_payload['Severity']['Normalized'] = int(severity * 17.5)

        self.aff_payload['Types'].append('Unusual Behaviors/VM')

        object_key = self.ds_event['Key']
        self.aff_payload['Title'] = generate_title(f'Unexpected change to object: {object_key}')

        return True

    def _process_log_inspection(self):
        get_ossec_level = self.ds_event.get('OSSEC_Level')
        ossec_level = int(get_ossec_level) if get_ossec_level else None

        if not ossec_level or ossec_level < LOG_INSPECTION_THRESHOLD:
            self._print_threshold_message('Log Inspection', LOG_INSPECTION_THRESHOLD, above_threshold=False)

            return False

        self._print_threshold_message('Log Inspection', LOG_INSPECTION_THRESHOLD, above_threshold=True)

        self.aff_payload['Severity']['Product'] = ossec_level

        if ossec_level >= 13:
            # to match the 71-100 range in the AFF format
            self.aff_payload['Severity']['Normalized'] = int(ossec_level * 6.5)
        else:
            # to match the 31-70 range in the AFF format
            self.aff_payload['Severity']['Normalized'] = int(ossec_level * 5)

        self.aff_payload['Types'].append('Unusual Behaviors/VM')
        self.aff_payload['Types'].append('Unusual Behaviors/Application')

        ossec_description = self.ds_event['OSSEC_Description']
        self.aff_payload['Title'] = generate_title(ossec_description)

        return True

    def _process_app_control_event(self):
        # Application control events
        print(f'App Control event from Deep Security from {self.host_instance_id}')
        self.aff_payload['Types'].append('Unusual Behaviors/Application')

        return True

    def process_ds_event(self):
        """
        Evaluate the specified Deep Security for security importance
        """

        above_threshold = self.event_processor[self.event_type]()

        if above_threshold:
            return self.aff_payload

        return False

    def _generate_aff_payload(self):
        """
        Convert a Deep Security to the Amazon Finding Format with all required and
        any applicable option properties
        """

        # AWS account for the event source pulled from Deep Security AWS cloud connector
        hostname = self.ds_event.get('Hostname', 'N/A')
        tenant_name = self.ds_event.get('TenantName', 'N/A')
        event_id = self.ds_event['EventID']
        tenant_id = self.ds_event['TenantID']
        host_id = self.ds_event.get('HostID', 'N/A')
        host_owner_id = self.ds_event['HostOwnerID']
        host_asset_val = self.ds_event.get('HostAssetValue', 'N/A')
        host_group_id = self.ds_event.get('HostGroupID', 'N/A')
        host_group_name = self.ds_event.get('HostGroupName', 'N/A')
        host_sec_pol_name = self.ds_event.get('HostSecurityPolicyName', 'N/A')
        host_sec_pol_id = self.ds_event.get('HostSecurityPolicyID', 'N/A')

        aff_event_type = AFF_EVENT_TYPES[self.event_type]
        log_date = self.ds_event['LogDate']  # ISO8601 formatted
    
        current_tme = datetime.datetime.utcnow().isoformat()
        # Z suffix required by API
        msg_date = f'{current_tme}Z'


    
        aff_format = {
            'SchemaVersion': '2018-10-08',
            'Id': f'{AWS_REGION}/{host_owner_id}/{self.host_instance_id}/{tenant_id}/{event_id}',
            'ProductArn': DS_PRODUCT_ARNS[AWS_REGION],
            'GeneratorId': f'trend-micro-deep-security-{aff_event_type}',
            'AwsAccountId': host_owner_id,
            'Types': [],  # Specific types are added to align with event type
            'FirstObservedAt': log_date,
            'UpdatedAt': msg_date,
            'CreatedAt': msg_date,
            'Severity': {
                'Product': 0,
                'Normalized': 0,
            },
            'ProductFields': {
                'trend-micro:TenantName': tenant_name,
                'trend-micro:TenantID': str(tenant_id),
                'trend-micro:EventID': str(event_id),
                'trend-micro:HostAssetValue': str(host_asset_val),
                'trend-micro:HostGroupID': str(host_group_id),
                'trend-micro:HostGroupName': host_group_name,
                'trend-micro:HostID': str(host_id),
                'trend-micro:HostInstanceID': str(self.host_instance_id),
                'trend-micro:Hostname': hostname,
                'trend-micro:HostSecurityPolicyID': str(host_sec_pol_id),
                'trend-micro:HostSecurityPolicyName': host_sec_pol_name,
            },
            'RecordState': 'ACTIVE',
            'Resources': [
                {
                    'Type': 'AwsEc2Instance',
                    'Id': self.host_instance_id,
                }
            ],
        }
    
        if 'Tags' in self.ds_event:
            aff_format['ProductFields']['trend-micro:Tags'] = self.ds_event['Tags']
        if 'OriginString' in self.ds_event:
            aff_format['ProductFields']['trend-micro:Origin'] = self.ds_event['OriginString']

        return aff_format

    def _print_threshold_message(self, event_type, threshold, above_threshold, additional_info=''):
        if above_threshold:
            msg = f'{event_type} event detected on {self.host_instance_id}. It is ABOVE the threshold of '\
                f'{threshold} so WILL be sent to Security Hub'

        else:
            msg = f'{event_type} event detected on {self.host_instance_id}. It is BELOW the threshold of '\
                f'{threshold} so WILL NOT be sent to Security Hub'

        if additional_info:
            print(f'{msg} - {additional_info}')

        else:
            print(msg)


def generate_title(title):
    """
    Generate a consistent title for a finding in AWS Security Hub
    * Setup as a function for consistency
    """
    
    return f'Trend Micro - {title}'


def verify_required_properties(sec_event):
    """
    Verify if the specified Deep Security event contains the required properties to
    be convert to an Amazon Finding Format finding
    """

    for entry in AFF_REQUIRED_PROPERTIES:
        if entry not in sec_event:
            event_type = sec_event['EventType']

            print(f'Not a valid {event_type} event - Missing required property: {entry} - The problematic '
                  f'event will be printed below:')
            print(json.dumps(sec_event))
            return False

    return True


def get_security_hub_client(acct_number):
    """
    Get an AWS Security Hub client using the appropriate credentials
    for the specified AWS account number
    """

    sts = boto3.client('sts')
    master_acct = sts.get_caller_identity().get('Account')

    if acct_number == master_acct:
        print(f'Current account {acct_number} is the owner of these events. Skipping assume role step.')
        securityhub = boto3.client('securityhub')

        return securityhub

    print(f'Assuming role for {acct_number}')
    role_arn = f'arn:aws:iam::{acct_number}:role/trend-micro-aff-forward-to-aws-security-hub'

    try:
        sts_response = sts.assume_role(
            RoleArn=role_arn,
            RoleSessionName='deep-security-aff-event-forward-to-aws-security-hub'
        )

    except ClientError as err:
        print(f'Could not assume role for account {acct_number} - {err}')

        return False

    credentials = sts_response['Credentials']

    print(f'Creating SecurityHub Boto3 client with assumed credentials from account {acct_number}')

    securityhub = boto3.client(
        'securityhub',
        region_name=AWS_REGION,
        aws_access_key_id=credentials['AccessKeyId'],
        aws_secret_access_key=credentials['SecretAccessKey'],
        aws_session_token=credentials['SessionToken']
    )

    return securityhub


def send_events_to_hub(acct_number, aff_events):
    """
    Send the specified Amazon Finding Format events to the AWS Security Hub
    """

    securityhub = get_security_hub_client(acct_number)

    # if we cannot assume the role, do not try to send findings
    if not securityhub:
        return False

    print(f'Importing AFF events for {acct_number}')
    response = securityhub.batch_import_findings(Findings=aff_events)
    resp_code = response['ResponseMetadata']['HTTPStatusCode']
    success = response['SuccessCount']
    failed = response['FailedCount']

    if not resp_code == 200:
        print(f'Error when trying to importing AFF events for {acct_number}. Response will be printed below:')

    else:
        print(f'Results from importing AFF events for {acct_number} - Success: {success} - Failed: {failed} - Full '
              f'response will be printed below:')

    print(json.dumps(response))


def extract_sec_events(event) -> list:
    """
    Iterates over all AWS 'Records' then joins them to form a single list.
    """

    all_events = []

    for record in event['Records']:
        extract_events = (record['Sns']['Message'])
        json_events = json.loads(extract_events)

        for event in json_events:
            all_events.append(event)

    num_events = len(all_events)
    print(f'Found {num_events} Deep Security events... Processing.')
    return all_events


def lambda_handler(event, context):
    print('Received SNS notification. Payload will be printed below:')
    print(json.dumps(event))
    sec_events = extract_sec_events(event)

    valid_events = []

    for sec_event in sec_events:
        valid_event = verify_required_properties(sec_event)
        if valid_event:
            valid_events.append(sec_event)

    aff_queue = dict()

    for ds_event in valid_events:
        ds = DeepSec(ds_event)

        # convert Deep Security event to an AFF event
        aff_event = ds.process_ds_event()

        # Skip events which are under threshold
        if not aff_event:
            continue

        aws_acct = aff_event['AwsAccountId']
        print(f'AFF event for {aws_acct} will be printed below:')
        print(json.dumps(aff_event))

        # split events by Account ID
        aff_queue.setdefault(aws_acct, []).append(aff_event)

    for acct_num, acct_aff_events in aff_queue.items():
        num_events = len(acct_aff_events)
        print(f'Sending {num_events} events to AWS Security Hub for account {acct_num}')
        send_events_to_hub(acct_num, acct_aff_events)
